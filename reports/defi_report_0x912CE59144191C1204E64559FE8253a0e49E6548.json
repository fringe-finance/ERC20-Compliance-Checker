{
    "data": {
        "project": {
            "address": "0x912ce59144191c1204e64559fe8253a0e49e6548",
            "contractName": "TransparentUpgradeableProxy",
            "coreIssues": [
                {
                    "issues": [],
                    "scwDescription": "No vulnerable withdrawal functions found",
                    "scwId": "105",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No reentrancy risk found",
                    "scwId": "107",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No locks detected",
                    "scwId": "150",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Verified source code found",
                    "scwId": "185",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [
                                {
                                    "description": "Not found.",
                                    "title": "Mint max supply"
                                },
                                {
                                    "description": "Timelock 8760H",
                                    "title": "Mint Timelock"
                                }
                            ],
                            "data": "{\"max_supply\": \"\", \"timelock\": \"31536000\", \"privileged\": [{\"type\": \"function\", \"value\": \"owner\", \"modifiable\": true}], \"mintUntil\": [{\"type\": \"var\", \"value\": \"nextMint\"}]}",
                            "description": "Mint function: L2ArbitrumToken.mint(address,uint256) (L2ArbitrumToken.sol#75-85)\n\t- in internal call: _mint(recipient,amount)\n\t\t- In expression: _balances[account] += amount\n",
                            "end": 85,
                            "governanceInfo": {
                                "owners": [
                                    {
                                        "owner": "0xCF57572261c7c2BCF21ffD220ea7d1a27D40A827",
                                        "timelockDelay": null,
                                        "type": "5"
                                    }
                                ],
                                "worstOwner": {
                                    "owner": "0xCF57572261c7c2BCF21ffD220ea7d1a27D40A827",
                                    "timelockDelay": null,
                                    "type": "5"
                                }
                            },
                            "id": 155285877,
                            "impact": "Informational",
                            "severityChanges": [
                                {
                                    "from": "Critical",
                                    "reason": "MintTimelock. Long timelock (> 30 days)",
                                    "to": "High"
                                }
                            ],
                            "snippet": "function mint(address recipient, uint256 amount) external onlyOwner {\n    // function inspired by: https://github.com/ensdomains/governance/blob/548f3f3607c83717427d9ae3fc1f3a9e66fc7642/contracts/ENSToken.sol#L105\n    require(\n        amount <= (totalSupply() * MINT_CAP_NUMERATOR) / MINT_CAP_DENOMINATOR,\n        \"ARB: MINT_TOO_MUCH\"\n    );\n    require(block.timestamp >= nextMint, \"ARB: MINT_TOO_EARLY\");\n    nextMint = block.timestamp + MIN_MINT_INTERVAL;\n    _mint(recipient, amount);\n}",
                            "start": 75
                        }
                    ],
                    "scwDescription": "A large amount of this token can be minted by a private wallet or contract.",
                    "scwId": "186",
                    "scwTitle": "Mintable"
                },
                {
                    "issues": [],
                    "scwDescription": "Users can always transfer their tokens",
                    "scwId": "189",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "data": "{\"privileged\": [{\"type\": \"event\", \"value\": \"AdminChanged(address,address)\", \"index\": \"1\", \"modifiable\": true}]}",
                            "description": "Proxy upgradeability: TransparentUpgradeableProxy.upgradeToAndCall(address,bytes) (TransparentUpgradeableProxy.sol#106-108)\n",
                            "end": 108,
                            "governanceInfo": {
                                "owners": [
                                    {
                                        "owner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                                        "timelockDelay": null,
                                        "type": "5"
                                    }
                                ],
                                "worstOwner": {
                                    "owner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                                    "timelockDelay": null,
                                    "type": "5"
                                }
                            },
                            "id": 132151689,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n    _upgradeToAndCall(newImplementation, data, true);\n}",
                            "start": 106
                        },
                        {
                            "additionalData": [],
                            "data": "{\"privileged\": [{\"type\": \"event\", \"value\": \"AdminChanged(address,address)\", \"index\": \"1\", \"modifiable\": true}]}",
                            "description": "Proxy upgradeability: TransparentUpgradeableProxy.upgradeTo(address) (TransparentUpgradeableProxy.sol#95-97)\n",
                            "end": 97,
                            "governanceInfo": {
                                "owners": [
                                    {
                                        "owner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                                        "timelockDelay": null,
                                        "type": "5"
                                    }
                                ],
                                "worstOwner": {
                                    "owner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                                    "timelockDelay": null,
                                    "type": "5"
                                }
                            },
                            "id": 132151690,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n}",
                            "start": 95
                        }
                    ],
                    "scwDescription": "This contract can be upgraded, changing its functionality.",
                    "scwId": "193",
                    "scwTitle": "Proxy Upgradeability"
                },
                {
                    "issues": [],
                    "scwDescription": "Wallets cannot be blacklisted from transfering the token",
                    "scwId": "208",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No transfer fees found",
                    "scwId": "209",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No transfer limits found",
                    "scwId": "211",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No ERC20 approval vulnerability found",
                    "scwId": "216-a",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Contract owner cannot abuse ERC20 approvals",
                    "scwId": "216-b",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No ERC20 interface errors found",
                    "scwId": "204-a",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No blocking loops found",
                    "scwId": "218",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No centralized balance controls found",
                    "scwId": "220",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No transfer cooldown times found",
                    "scwId": "219",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No approval restrictions found",
                    "scwId": "223",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "data": "",
                            "description": "Possible Honeypot:\n\t- Function: ERC20Upgradeable.transfer(address,uint256) (ERC20Upgradeable.sol#118-122)\n\t\t- External call: SafeCastUpgradeable.toUint224(newWeight)\t\t- External call: SafeCastUpgradeable.toUint224(newWeight)\t\t- External call: SafeCastUpgradeable.toUint32(block.number)",
                            "end": 122,
                            "governanceInfo": null,
                            "id": 155285878,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}",
                            "start": 118
                        },
                        {
                            "additionalData": [],
                            "data": "",
                            "description": "Possible Honeypot:\n\t- Function: ERC20Upgradeable.transferFrom(address,address,uint256) (ERC20Upgradeable.sol#163-172)\n\t\t- External call: SafeCastUpgradeable.toUint224(newWeight)\t\t- External call: SafeCastUpgradeable.toUint224(newWeight)\t\t- External call: SafeCastUpgradeable.toUint32(block.number)",
                            "end": 172,
                            "governanceInfo": null,
                            "id": 155285879,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n}",
                            "start": 163
                        }
                    ],
                    "scwDescription": "The contract contains external calls which cannot be analyzed by the scanner, and could be potentially dangerous. Please use caution when using this contract.",
                    "scwId": "210-b",
                    "scwTitle": "Potential Honeypot"
                },
                {
                    "issues": [],
                    "scwDescription": "No airdrop-specific code found",
                    "scwId": "10004",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "data": "",
                            "description": "Function that can set owner:L2ArbitrumToken.initialize(address,uint256,address) (L2ArbitrumToken.sol#52-70)\t in internal call: _transferOwnership\t\t in expression: _owner = newOwner",
                            "end": 70,
                            "governanceInfo": null,
                            "id": 155285883,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function initialize(address _l1TokenAddress, uint256 _initialSupply, address _owner)\n    public\n    initializer\n    require(_l1TokenAddress != address(0), \"ARB: ZERO_L1TOKEN_ADDRESS\");\n    require(_initialSupply != 0, \"ARB: ZERO_INITIAL_SUPPLY\");\n    require(_owner != address(0), \"ARB: ZERO_OWNER\");\n    __ERC20_init(NAME, SYMBOL);\n    __ERC20Burnable_init();\n    __ERC20Permit_init(NAME);\n    __ERC20Votes_init();\n    __Ownable_init();\n    _mint(_owner, _initialSupply);\n    nextMint = block.timestamp + MIN_MINT_INTERVAL;\n    l1Address = _l1TokenAddress;\n    _transferOwnership(_owner);\n}",
                            "start": 52
                        }
                    ],
                    "scwDescription": "The contract's owner can be changed by anyone.",
                    "scwId": "230",
                    "scwTitle": "Vulnerable Ownership"
                },
                {
                    "issues": [],
                    "scwDescription": "No retrievable ownership found.",
                    "scwId": "231",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Contract was not deployed recently.",
                    "scwId": "10010",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No mixers utilized by contract deployer.",
                    "scwId": "10003",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No adjustable maximum supply found.",
                    "scwId": "233",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No previous scams by owner's wallet found.",
                    "scwId": "10016",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "The contract operates without custom fees, ensuring security and financial integrity.",
                    "scwId": "236",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Smart contract lacks a whitelisting feature, reinforcing standard restrictions and access controls, enhancing overall security and integrity.",
                    "scwId": "237",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Smart contract's transfer function secure with unchangeable router, no issues, ensuring smooth, secure token transfers.",
                    "scwId": "238",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Smart contract safeguarded against native token draining in token transfers/approvals.",
                    "scwId": "239",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Smart contract with recent user interactions, active use, and operational functionality, not abandoned.",
                    "scwId": "10022",
                    "scwTitle": "Recent Interaction was within 30 Days."
                },
                {
                    "issues": [],
                    "scwDescription": "No instances of native token drainage upon revoking tokens were detected in the contract.",
                    "scwId": "10023",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Securely hardcoded Uniswap router ensuring protection against router alterations.",
                    "scwId": "241",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "AI model detects robust, genuine token and user activity, earning a high score, indicating trustworthiness and community integrity.",
                    "scwId": "10024",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [
                                {
                                    "description": "89%",
                                    "title": "Percent of revokes in last approves:"
                                }
                            ],
                            "data": null,
                            "description": "89% of the latest approval transactions on this contract are revokes. An unusually large number of revoke from this contract (compared to approvals) might indicate that users consider it malicious",
                            "end": null,
                            "governanceInfo": null,
                            "id": -34,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "",
                            "start": null
                        }
                    ],
                    "scwDescription": "Contract faces excessive revocations, raising concerns about functionality and security.",
                    "scwId": "10025",
                    "scwTitle": "Revocation Rate"
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "data": "",
                            "description": "Unprotected initialize function: L2ArbitrumToken.initialize(address,uint256,address) (L2ArbitrumToken.sol#52-70)\n",
                            "end": 70,
                            "governanceInfo": null,
                            "id": 155285882,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function initialize(address _l1TokenAddress, uint256 _initialSupply, address _owner)\n    public\n    initializer\n    require(_l1TokenAddress != address(0), \"ARB: ZERO_L1TOKEN_ADDRESS\");\n    require(_initialSupply != 0, \"ARB: ZERO_INITIAL_SUPPLY\");\n    require(_owner != address(0), \"ARB: ZERO_OWNER\");\n    __ERC20_init(NAME, SYMBOL);\n    __ERC20Burnable_init();\n    __ERC20Permit_init(NAME);\n    __ERC20Votes_init();\n    __Ownable_init();\n    _mint(_owner, _initialSupply);\n    nextMint = block.timestamp + MIN_MINT_INTERVAL;\n    l1Address = _l1TokenAddress;\n    _transferOwnership(_owner);\n}",
                            "start": 52
                        }
                    ],
                    "scwDescription": "Unprotected contract initializer, vulnerable to re-execution, immediate action needed for security.",
                    "scwId": "242",
                    "scwTitle": "Unprotected Initializer"
                },
                {
                    "issues": [],
                    "scwDescription": "Smart contract intact, not self-destructed, ensuring continuity and functionality.",
                    "scwId": "10026",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "Contract's timelock setting aligns with 24 hours or more, enhancing security and reliability.",
                    "scwId": "10027",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No suspicious activity has been detected.",
                    "scwId": "10028",
                    "scwTitle": null
                }
            ],
            "diffs": null,
            "estimatedAnalyzingTime": 0,
            "firstTxBlock": null,
            "firstTxDate": "2023-03-16T14:31:10.000Z",
            "firstTxFrom": "0x5d2eb5259bd4ee8989ba453046f49f1c8603c7db",
            "generalIssues": [
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Different versions of Solidity is used:\n\t- Version used: ['0.8.16', '^0.8.0', '^0.8.1', '^0.8.16', '^0.8.2']\n\t- ^0.8.0 (OwnableUpgradeable.sol#4)\n\t- ^0.8.0 (IVotesUpgradeable.sol#3)\n\t- ^0.8.2 (Initializable.sol#4)\n\t- ^0.8.0 (ERC20Upgradeable.sol#4)\n\t- ^0.8.0 (IERC20Upgradeable.sol#4)\n\t- ^0.8.0 (ERC20BurnableUpgradeable.sol#4)\n\t- ^0.8.0 (ERC20VotesUpgradeable.sol#4)\n\t- ^0.8.0 (IERC20MetadataUpgradeable.sol#4)\n\t- ^0.8.0 (draft-ERC20PermitUpgradeable.sol#4)\n\t- ^0.8.0 (draft-IERC20PermitUpgradeable.sol#4)\n\t- ^0.8.1 (AddressUpgradeable.sol#4)\n\t- ^0.8.0 (ContextUpgradeable.sol#4)\n\t- ^0.8.0 (CountersUpgradeable.sol#4)\n\t- ^0.8.0 (StringsUpgradeable.sol#4)\n\t- ^0.8.0 (ECDSAUpgradeable.sol#4)\n\t- ^0.8.0 (draft-EIP712Upgradeable.sol#4)\n\t- ^0.8.0 (MathUpgradeable.sol#4)\n\t- ^0.8.0 (SafeCastUpgradeable.sol#4)\n\t- ^0.8.1 (AddressUpgradeable.sol#4)\n\t- ^0.8.0 (ContextUpgradeable.sol#4)\n\t- ^0.8.0 (CountersUpgradeable.sol#4)\n\t- ^0.8.0 (ECDSAUpgradeable.sol#4)\n\t- ^0.8.0 (ERC20BurnableUpgradeable.sol#4)\n\t- ^0.8.0 (ERC20Upgradeable.sol#4)\n\t- ^0.8.0 (ERC20VotesUpgradeable.sol#4)\n\t- ^0.8.0 (IERC20MetadataUpgradeable.sol#4)\n\t- ^0.8.0 (IERC20Upgradeable.sol#4)\n\t- ^0.8.0 (IVotesUpgradeable.sol#3)\n\t- ^0.8.2 (Initializable.sol#4)\n\t- 0.8.16 (L2ArbitrumToken.sol#2)\n\t- ^0.8.0 (MathUpgradeable.sol#4)\n\t- ^0.8.0 (OwnableUpgradeable.sol#4)\n\t- ^0.8.0 (SafeCastUpgradeable.sol#4)\n\t- ^0.8.0 (StringsUpgradeable.sol#4)\n\t- ^0.8.16 (TransferAndCallToken.sol#3)\n\t- ^0.8.0 (draft-EIP712Upgradeable.sol#4)\n\t- ^0.8.0 (draft-ERC20PermitUpgradeable.sol#4)\n\t- ^0.8.0 (draft-IERC20PermitUpgradeable.sol#4)\n\t- ^0.8.0 (IERC20MetadataUpgradeable.sol#4)\n\t- ^0.8.0 (IVotesUpgradeable.sol#3)\n\t- ^0.8.2 (Initializable.sol#4)\n\t- ^0.8.1 (AddressUpgradeable.sol#4)\n\t- ^0.8.0 (ContextUpgradeable.sol#4)\n\t- ^0.8.0 (CountersUpgradeable.sol#4)\n\t- ^0.8.0 (StringsUpgradeable.sol#4)\n\t- ^0.8.0 (ECDSAUpgradeable.sol#4)\n\t- ^0.8.0 (draft-EIP712Upgradeable.sol#4)\n\t- ^0.8.0 (MathUpgradeable.sol#4)\n\t- ^0.8.0 (SafeCastUpgradeable.sol#4)\n",
                            "end": 4,
                            "governanceInfo": null,
                            "id": 155285859,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity ^0.8.0;",
                            "start": 4
                        }
                    ],
                    "scwDescription": "This contract may not function as expected due to inconsistent solidity compiler versions being specified.",
                    "scwId": "103",
                    "scwTitle": "Floating Pragma"
                },
                {
                    "issues": [],
                    "scwDescription": "No unchecked call responses found",
                    "scwId": "104",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable self-destruct functions found",
                    "scwId": "106",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No assertion vulnerabilities found",
                    "scwId": "110",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No old solidity code found",
                    "scwId": "111",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No external delegated calls found",
                    "scwId": "112",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No external call dependency found",
                    "scwId": "113",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable authentication calls found",
                    "scwId": "115",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No invalid character typos found",
                    "scwId": "129",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No RTL characters found",
                    "scwId": "130",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No dead code found",
                    "scwId": "135",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No risky data allocation found",
                    "scwId": "138",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No uninitialized state variables found",
                    "scwId": "142",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No uninitialized storage variables found",
                    "scwId": "143",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable initialization functions found",
                    "scwId": "144",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No risky data handling found",
                    "scwId": "145",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No number accuracy bug found",
                    "scwId": "146",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No out-of-range number vulnerability found",
                    "scwId": "147",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No map data deletion vulnerabilities found",
                    "scwId": "151",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No tautologies or contradictions found",
                    "scwId": "152",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No faulty true/false values found",
                    "scwId": "153",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse = (3 * denominator) ^ 2 (MathUpgradeable.sol#117)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285860,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#121)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285861,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#122)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285862,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#123)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285863,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#124)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285864,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#125)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285865,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-denominator = denominator / twos (MathUpgradeable.sol#102)\n\t-inverse *= 2 - denominator * inverse (MathUpgradeable.sol#126)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285866,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "MathUpgradeable.mulDiv(uint256,uint256,uint256) (MathUpgradeable.sol#55-135) performs a multiplication on the result of a division:\n\t-prod0 = prod0 / twos (MathUpgradeable.sol#105)\n\t-result = prod0 * inverse (MathUpgradeable.sol#132)\n",
                            "end": 135,
                            "governanceInfo": null,
                            "id": 155285867,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            return prod0 / denominator;\n        }\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}",
                            "start": 55
                        }
                    ],
                    "scwDescription": "The order of operations used may result in a loss of precision.",
                    "scwId": "156",
                    "scwTitle": "Division Before Multiplication"
                },
                {
                    "issues": [],
                    "scwDescription": "No redundant constructor calls found",
                    "scwId": "157",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable transfers found",
                    "scwId": "158",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable return values found",
                    "scwId": "159",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "ERC20VotesUpgradeable._moveVotingPower(address,address,uint256).oldWeight_scope_0 (ERC20VotesUpgradeable.sol#226) is a local variable never initialized\n",
                            "end": 226,
                            "governanceInfo": null,
                            "id": 155285880,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "(uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                            "start": 226
                        },
                        {
                            "additionalData": [],
                            "confidence": "Medium",
                            "description": "ERC20VotesUpgradeable._moveVotingPower(address,address,uint256).newWeight_scope_1 (ERC20VotesUpgradeable.sol#226) is a local variable never initialized\n",
                            "end": 226,
                            "governanceInfo": null,
                            "id": 155285881,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "(uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                            "start": 226
                        }
                    ],
                    "scwDescription": "This contract's local variables are not all initialized, potentially resulting in lost funds or other exploits.",
                    "scwId": "160",
                    "scwTitle": "Uninitialized Local Variables"
                },
                {
                    "issues": [],
                    "scwDescription": "No default function responses found",
                    "scwId": "161",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No missing arithmetic events found",
                    "scwId": "167-a",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No missing access control events found",
                    "scwId": "167-b",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No missing zero address checks found",
                    "scwId": "168",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No redundant true/false comparisons found",
                    "scwId": "170",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No state variables vulnerable through function calls found",
                    "scwId": "172",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Low level call in AddressUpgradeable.sendValue(address,uint256) (AddressUpgradeable.sol#60-65):\n\t- (success) = recipient.call{value: amount}() (AddressUpgradeable.sol#63)\n",
                            "end": 65,
                            "governanceInfo": null,
                            "id": 155285874,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n}",
                            "start": 60
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Low level call in AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (AddressUpgradeable.sol#128-139):\n\t- (success,returndata) = target.call{value: value}(data) (AddressUpgradeable.sol#137)\n",
                            "end": 139,
                            "governanceInfo": null,
                            "id": 155285875,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    require(isContract(target), \"Address: call to non-contract\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}",
                            "start": 128
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Low level call in AddressUpgradeable.functionStaticCall(address,bytes,string) (AddressUpgradeable.sol#157-166):\n\t- (success,returndata) = target.staticcall(data) (AddressUpgradeable.sol#164)\n",
                            "end": 166,
                            "governanceInfo": null,
                            "id": 155285876,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}",
                            "start": 157
                        }
                    ],
                    "scwDescription": "This contract uses low level calls, which may be unsafe.",
                    "scwId": "173",
                    "scwTitle": "Low Level Calls"
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Pragma version^0.8.0 (OwnableUpgradeable.sol#4) allows old versions\n",
                            "end": 4,
                            "governanceInfo": null,
                            "id": 155285868,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity ^0.8.0;",
                            "start": 4
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Pragma version^0.8.2 (Initializable.sol#4) allows old versions\n",
                            "end": 4,
                            "governanceInfo": null,
                            "id": 155285869,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity ^0.8.2;",
                            "start": 4
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Pragma version^0.8.1 (AddressUpgradeable.sol#4) allows old versions\n",
                            "end": 4,
                            "governanceInfo": null,
                            "id": 155285870,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity ^0.8.1;",
                            "start": 4
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Pragma version0.8.16 (L2ArbitrumToken.sol#2) necessitates a version too recent to be trusted. Consider deploying with 0.6.12/0.7.6/0.8.7\n",
                            "end": 2,
                            "governanceInfo": null,
                            "id": 155285871,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity 0.8.16;",
                            "start": 2
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "Pragma version^0.8.16 (TransferAndCallToken.sol#3) necessitates a version too recent to be trusted. Consider deploying with 0.6.12/0.7.6/0.8.7\n",
                            "end": 3,
                            "governanceInfo": null,
                            "id": 155285872,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "pragma solidity ^0.8.16;",
                            "start": 3
                        },
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "solc-0.8.16 is not recommended for deployment\n",
                            "end": 0,
                            "governanceInfo": null,
                            "id": 155285873,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "",
                            "start": 0
                        }
                    ],
                    "scwDescription": "This contract uses an unconventional or very old version of Solidity.",
                    "scwId": "177",
                    "scwTitle": "Incorrect Solidity Version"
                },
                {
                    "issues": [],
                    "scwDescription": "No expensive loops found",
                    "scwId": "179",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No bad numeric notation practices found",
                    "scwId": "182",
                    "scwTitle": null
                },
                {
                    "issues": [
                        {
                            "additionalData": [],
                            "confidence": "High",
                            "description": "ERC20PermitUpgradeable._PERMIT_TYPEHASH_DEPRECATED_SLOT (draft-ERC20PermitUpgradeable.sol#40) should be constant\n",
                            "end": 40,
                            "governanceInfo": null,
                            "id": 155285858,
                            "impact": "Informational",
                            "severityChanges": [],
                            "snippet": "bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;",
                            "start": 40
                        }
                    ],
                    "scwDescription": "Some state variables in this contract should be declared as constant.",
                    "scwId": "183",
                    "scwTitle": "State Variables Should be Declared Constant"
                },
                {
                    "issues": [],
                    "scwDescription": "No missing external function declarations found",
                    "scwId": "184",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable payable functions found",
                    "scwId": "224",
                    "scwTitle": null
                },
                {
                    "issues": [],
                    "scwDescription": "No vulnerable message values found",
                    "scwId": "225",
                    "scwTitle": null
                }
            ],
            "governance": {
                "contractOwners": [
                    {
                        "governance": null,
                        "impact": "High",
                        "modifiable": true,
                        "multisig": null,
                        "owner": "0xcf57572261c7c2bcf21ffd220ea7d1a27d40a827",
                        "timelock": null,
                        "timelockDelay": null,
                        "type": "5"
                    }
                ],
                "issueOwners": [
                    {
                        "owners": [
                            {
                                "governance": null,
                                "impact": "High",
                                "modifiable": true,
                                "multisig": null,
                                "owner": "0xCF57572261c7c2BCF21ffD220ea7d1a27D40A827",
                                "timelock": null,
                                "timelockDelay": null,
                                "type": "5"
                            }
                        ],
                        "scwId": "186"
                    }
                ],
                "proxyOwners": [
                    {
                        "governance": null,
                        "impact": "High",
                        "modifiable": true,
                        "multisig": null,
                        "owner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                        "timelock": null,
                        "timelockDelay": null,
                        "type": "5"
                    }
                ],
                "visibleOwner": "0xcf57572261c7c2bcf21ffd220ea7d1a27d40a827"
            },
            "inProgress": false,
            "initialFunder": "0x80c67432656d59144ceff962e8faf8926599bcf8",
            "isProxyImplementation": false,
            "logo": "",
            "name": "TransparentUpgradeableProxy",
            "network": 42161,
            "pairInfo": null,
            "projectFullName": "",
            "projectName": "",
            "protocol": "erc20",
            "proxyContractAddress": null,
            "proxyData": {
                "implementationData": {
                    "firstTxBlock": null,
                    "firstTxDate": "2023-03-16T12:06:19.000Z",
                    "firstTxFrom": "0x2b9acfd85440b7828db8e54694ee07b2b056b30c",
                    "initialFunder": "0xb311a5308599d81542b33d1da9ffdf8c02fc8321",
                    "initialFunding": 5,
                    "name": "L2ArbitrumToken"
                },
                "proxyIssues": [
                    {
                        "issues": [],
                        "scwDescription": "No reentrancy risk found",
                        "scwId": "107",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "No locks detected",
                        "scwId": "150",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "Verified source code found",
                        "scwId": "185",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "Users can always transfer their tokens",
                        "scwId": "189",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "Wallets cannot be blacklisted from transfering the token",
                        "scwId": "208",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "No ERC20 approval vulnerability found",
                        "scwId": "216-a",
                        "scwTitle": null
                    },
                    {
                        "issues": [],
                        "scwDescription": "Contract owner cannot abuse ERC20 approvals",
                        "scwId": "216-b",
                        "scwTitle": null
                    }
                ],
                "proxyOwner": "0xdb216562328215E010F819B5aBe947bad4ca961e",
                "sourceCodeLink": "https://scan-results.de.fi/0x912ce59144191c1204e64559fe8253a0e49e6548_42161_src.json"
            },
            "rektLink": null,
            "sourceCodeLink": "https://scan-results.de.fi/0xc4ed0a9ea70d5bcc69f748547650d32cc219d882_42161_src.json",
            "stats": {
                "percentage": 100,
                "scammed": false
            },
            "whitelisted": true
        }
    }
}